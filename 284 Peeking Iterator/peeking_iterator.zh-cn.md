# 284. Peeking Iterator

## 分类
* 设计

## 解法
Peek时调用父类的`next()`函数会导致迭代器向后移动，所以我们可以把结果缓存起来，下次调用`next()`的时候直接返回缓存中的结果并清空缓存。同样`hasNext()`函数要首先判断缓存中是否有值，如果有的话则返回`true`，否则调用父类的`hasNext()`函数。

* 时间复杂度：`O(1)`
* 空间复杂度：`O(1)`

## 边界条件
无

## 备注
无

## 参考文献
无